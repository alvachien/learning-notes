# lesson4_memory_gc

Maven project build with:
- Java 11 (OpenJDK 11)
- JUnit 5


# Key Takeaway

## GC的基本概念

基本上可以把JVM的内存引用对象理解成一种有向图，把引用变量、对象都当成有向图的顶点，将引用关系当成有向图的有向边，该有向边的方向总是从引用端指向被引用的对象。
对单线程程序来说，只有一条main线程，该线程就是有向图的一个顶点（只有出边）。

对垃圾回收机制来说，判断一个对象是否可以进行回收的标准在于该对象是否引用。从JDK 1.2开始，Java在java.lang.ref提供了三个类：
- SoftReference
- PhantomReference
- WeakReference

它们分别代表了系统对象的3中引用方式：软引用、虚引用和弱引用。

### 四种引用方式

#### 强引用

这是最常见的引用方式。创建一个对象，并将该对象赋给一个变量，这个引用变量就是强引用。

被强引用的Java对象绝不会给垃圾回收机制回收。所以，这是造成Java内存泄露的主要原因之一。

#### 软引用

软引用通过SoftReference类来实现。当一个对象只有一个软引用时，它有可能被垃圾回收机制回收（通常是系统内存空间不足时）。

#### 弱引用

弱引用跟软引用类似，但是引用级别更低。当系统垃圾回收机制运行时，不管系统内存是否足够，总是被回收。

#### 虚引用

软引用和弱引用可以单独使用，但是虚引用必须与引用队列联合使用。虚引用的主要作用就是跟踪对象被垃圾回收的状态，程序可以通过检查与虚作用关联的引用队列是否已经包括指定的虚引用，从而了解虚引用所引用对象是否即将被回收。

引用队列通过java.lang.ref.ReferenceQueue类表示，它用于保存被回收后对象的引用。
虚引用通过PhantomReference类实现。


## Java内存泄漏

Java内存泄漏是指内存对象没有及时释放，导致GC也不能回收。

ArrayList源码中的remove函数：
```java
public E remove(int index) {
    // ...
    elementData[--size] = null; // Ensure GC work
    // ...
}
```
