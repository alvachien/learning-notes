# lessonc_sorting

Maven project 
- Java 16
- JUnit 5


# Key takeaways

## 排序综述

一般来说从3个方面来核量算法的优劣：
- 时间复杂度；
- 空间复杂度；
- 稳定性；

排序大致可以分为内部排序和外部排序。
- 如果整个排序过程不需要借助外部存储器，所有排序操作都在内存完成，则为内部排序；
- 如果参与排序的数据元素过大，计算机无法将整个过程放在内存中完成，称为外部排序；

一般所说的排序都是指内部排序。

## 内部排序的分类

内部排序算法的分类：
- 选择排序：直接选择排序、堆排序
- 交换排序：冒泡排序、快速排序
- 插入排序：直接插入排序、折半插入排序、Shell排序
- 归并排序
- 桶式排序
- 基数排序


## 选择算法 Selection Sort

算法思路：

首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

- 选择排序的交换操作介于 0 和 (n - 1)次之间。选择排序的比较操作为 n (n - 1） / 2 次之间。
- 最好情况是，已经有序，交换0次；最坏情况交换n-1次，逆序交换n/2次。
- 选择排序是一个不稳定的排序算法。

## 堆排序 Heap Sort

堆排序类似于平衡二叉树。

- 每次通过建堆的方式选出当期数组中最大的，并把其与最后一个元素交换；
- 限制数组长度减一；
- 重复上述两步；

## 冒泡排序 Bubble Sort

冒泡排序：
- 每次比较0,1；1,2; ... ; n-2, n-1之间的结果并交换。这导致最大的值会被移到最后；
- 限制数组长度减一；
- 重复上述两步；

## 快速排序 Quick Sort

核心思想：
- 任取一个元素作为分界值，所有比它小的都放在左边，比它打的都放右边。
- 对其左子序列执行同样的操作。
- 对其右子序列执行同样的操作。

## 插入排序 Insert Sort

核心思想：
- 针对第二个元素，将其插入到有一个元素的序列的合适位置，使其有序；
- 针对第三个元素，将其插入到有两个元素的序列的合适位置，使其有序；
- 针对第N个元素，将其插入到有N-1个元素的序列的合适位置，使其有序；


## 折半插入排序

是插入排序的改良版本，就是在确定合适位置的时候，使用二分法查找。


## Shell排序

Shell排序也是对插入排序的改良，它主要为了避免当一个较小数字插入一个较大序列（已经有序的部分）所导致的大量数字移动。
它通过加大已经有序序列的间隔达到这个目的。默认的插入排序，已经有序数列中各个元素之间没有间隔。

## 归并排序 Merge Sort

归并排序将长度为N的序列看成n个长度为1 的有序子序列，首先两两合并，得到n/2个长度为2的有序子序列。不断重复，直到得到一个长度为n的有序序列。

## 桶式排序 Bucket Sort

桶式排序有两个前提条件
- 待排序序列的所有值处于一个可枚举的范围内；
- 可枚举范围不应该太大。

桶式排序就是根据可枚举范围创建新数组（即桶）：
- 首先，记录桶中个元素在队列中出现的次数。
- 其次，对桶中元素进行重新计算，每个元素的新值为其旧值与其前一个元素的旧值之和。

TBD

## 基数排序

基数排序的实质是多关键字排序。多关键字排序有两种解决方案：
- 最高位优先法 MSD (Most Significant Digit First)
- 最低位优先法 LSD (Least Significant Digit First)

TBD


